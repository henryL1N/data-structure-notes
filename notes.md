<style type="text/css">
    ol { list-style-type: decimal; }
</style>

1. 绪论
    1. 数据结构的概念及分类
        1. 为什么要学习数据结构
        2. 与数据结构相关的基本术语
            * 数据 data
            * 数据元素 data element
            * 数据项 data item
            * 数据结构 data structure
            * 数据对象 data object
            * 数据类型 data type
            * 抽象数据类型 Abstract Data Type, ADT
        3. 数据结构的分类
            * 逻辑结构的分类
                * 按数据元素之间关系分类
                    * 线性结构
                    * 非线形结构
                * 数据元素存取方法分类
                    * 直接存取结构
                    * 顺序存取结构
                    * 字典
            * 数据结构的存储结构
                * 考虑数据结构的存储方式的要素包括：
                    * 访问频率
                    * 修改频率
                    * 安全保密
                * 常用4中存储方式
                    * 顺序存储方式
                    * 链接存储方式
                    * 索引存储方式
                    * 散列存储方式
            * 定义在数据结构上的操作
                * 创建
                * 销毁
                * 查找
                * 插入
                * 删除
                * 排序
    2. 适用C语言描述数据结构
        1. C语言的数据类型
            * 构造型 struct
            * 联合型 union
            * 指针型
        2. 算法的控制结构
            * 顺序型
            * 选择型
                * if else
                * switch
            * 重复型
                * while
                * for
        3. 算法的函数结构
            * 函数的一般形式
            * 函数的参数传递
            * 函数的返回值
        4. 动态存储分配
        5. 逻辑和关系运算的约定
        6. 输入与输出
    3. 算法和箅法设计
        1. 算法的定义和特性
            * 有0个或多个输入
            * 有一个或多个输出
            * 确定性
            * 有穷性
            * 可行性
        2. 算法的设计步骤
            * 理解需求
            * 设计思路
            * 算法框架
            * 程序实现
        3. 算法设计的基本方法
            * 穷举法
            * 迭代法
            * 递推法
            * 递归法
        4. 箅法分析与度量
            * 算法的评价标准
                * 正确性
                * 健壮性
                * 可读性
                * 高效性
                * 简单性
            * 算法的时间和空间复杂性度量
2. 线性表
    1. 线性表
        1. 线性表的定义和特点
            * 线性表的特点
                * 有限序列
                    * 存在唯一的第一个元素和最后一个元素
                    * 除第一个元素外，其他元素有且仅有一个直接前趋；第一个元素没有直接前趋。
                * 每个元素具有相同的数据类型，且不能按子表那样分割
                * 每个元素具有“位置”和“值”
                * 元素的值与位置的关系可有可无
        2. 线性表的主要操作
            * 构造`void initList (List& L)`
            * 清空`void clearList (List& L)`
            * 判空`int isEmpty (List& L)`
            * 判满`int isFull (List& L)`
            * 长度`int Length (List& L)`
            * 定位`position Locate (List& L, int i}`
            * 查找`position Search (List& L, DataType x)`
            * 插入`int Insert (List& L, int i, DataType x)`
            * 删除`int Remove (List& L, int i, DataType& x)`
            * 遍历`void Traverse (List& L)`
            * 复制`void Copy (List& Ll, List& L2)`
            * 排序`void Sort (List& L)`
    2. 顺序表
        1. 顺序表的定义和特点
            * 顺序表的特点
                * 各元素的逻辑顺序与存放的物理顺序一致
                * 可顺序或随机访问元素
                * 可用C语言的一维数组实现
                * 线性表存储数组的数据类型就是顺序表中元素的数据类型，数组的大小要大于等于顺序表的长度
                * 第i个元素存储在一维数组i-1的位置上
        2. 顺序表的结构定义
        3. 顺序表主要操作的实现
        4. 顺序表主要操作的性能分析
        5. 顺序表的应用举例
    3. 单链表
        1. 单链表的定义和特点
            * 单链表的特点
                * 元素的逻辑顺序与其物理顺序可能不一致
                * 长度可扩充
                * 遍历或查找只能从头指针指示的首元结点开始
                * 插入或删除时只需修改相关结点的指针
                * 由于带有指针，存储需要的空间多
        2. 单链表的结构定义
        3. 单链表中指针的操作
        4. 单链表中的插人与删除
        5. 带头结点的单链表
            * 好处
                * 统一了空表和非空表的操作
                * 简化了链表的插入与删除操作代码的实现
        6. 单链表主要操作的性能分析
        7. 单链表的顺序访问与尾递归
        8. 单链表的应用举例
    4. 顺序表与线性链表的比较
        * 存储方面的比较
            * 顺序表存储密度高，存储利用率高
            * 线性链表空间限制少
            * 线性链表存储空间占用灵活
        * 存取方面的比较
            * 顺序表访问方式灵活
            * 线性链表插入删除快
        * 基于使用方面的考虑
            * 初始化、指针丢失
            * 需要回收空间
            * 频繁插入和删除选线性链表
    5. 线性链表的其他变形
        1. 循环链表
        2. 双向链表
        3. 静态链表
    6. 线性表的应用：一元多项式及其运算
        1. 一元多项式
        2. 多项式的结构定义
        3. 多项式的加法
        4. 多项式的乘法
3. 栈和队列
    1. 栈
        1. 栈的概念
            * 主要操作
                * 创建`void InitStack (Stack& S)`
                * 压栈`void Push (Stack& S, SElemType x)`
                * 出栈`int Pop (Stack& S, SElemType & x)`
                * 栈顶`int GetTop (Stack& S, SElemType & x)`
                * 判空`int StackEmpty (Stack& S)`
                * 判满`int StackFull (Stack& S)`
                * 栈长`int Stack&ize (Stack& S)`
        2. 顺序栈
        3. 链式栈
        4. 栈的混洗
    2. 队列
        1. 队列的概念
            * 主要操作
                * 创建`InitQueue (Queues Q)`
                * 入队`void EnQueue (Queues Q, QElemType x)`
                * 出队`int DeQueue (Queues Q,QElemType& x)`
                * 队头`int GetFront (Queues Q,QElemType& x)`
                * 判空`int QueueEmpty (Queues Q)`
                * 判满`int QueueFull (Queues Q)`
                * 队长`int QueueSize (Queues Q)`
        2. 循环队列
        3. 链式队列
    3. 栈的应用
        1. 数制转换
        2. 括号匹配
        3. 表达式的计算与优先级处理
        4. 栈与递归的实现
    4. 队列的应用
        1. 打印杨辉三角形与逐行处理
        2. 电路布线与两点间的最短路径
    5. 在算法设计中使用递归
        1. 汉诺塔问题与分治法
        2. 迷宫问题与回溯法
        3. 计算组合数与动态规划
            * 递归算法是低效的
            * 用动态规划法改善分治法的执行效率
    6. 双端队列
        1. 双端队列的概念
            * 两端插入、两端删除
            * 一端插入、两端删除
            * 两端插入、一端删除
        2. 输入受限的双端队列
        3. 输出受限的双端队列
        4. 双端队列的顺序存储表示
        5. 双端队列的链接存储表示
4. 数组、串和广义表
    1. 数组
        1. 一维数组
        2. 多维数组
        3. 数组的应用举例
    2. 特殊矩阵的压缩存储
        1. 对称矩阵的压缩存储
        2. 三对角矩阵的压缩存储
    3. 稀疏矩阵
        1. 稀疏矩阵的概念
        2. 稀疏矩阵的三元组表表示
        3. 稀疏矩阵的十字链表表示
    4. 字符串
        1. 字符串的概念
        2. 宇符串的初始化和赋值
        3. C语言中有关字符串的库函数
        4. 自定义字符串的存储表示
        5. 串的模式匹配
    5. 广义表
        1. 广义表的概念
        2. 广义表的性质
            * 有次序
            * 有长度
            * 有深度
            * 可递归
            * 可共享
        3. 广义表的链接表示
            * 头尾表示
            * 扩展线性链表表示
            * 层次表示
        4. 三元多项式的表示
5. 树与二叉树
    1. 树的基本概念
        1. 树的定义和术语
            * 定义
                * 自由树
                * 有根树
            * 基本术语
                * 结点 node
                * 结点的度 degree
                * 叶结点 leaf
                * 分支结点 branch
                * 子女结点 child
                * 父结点 parent
                * 兄弟结点 sibling
                * 祖先结点 ancestor
                * 子孙结点 descendant
                * 结点间的路径 path
                * 结点的深度 depth
                * 结点的高度 height
                * 树的深度 depth
                * 树的高度 height
                * 树的宽度 width
                * 树的度 degree
                * 有序树 ordered tree
                * 无序树
                * 森林 forest
        2. 树的基本操作
            * 创建`void InitTree (Tree& T)`
            * 删除`void ClearTree (TreeNode * & T)`
            * 首孩`position FirstChild (Tree& T, position p)`
            * 下兄`position NextSibling (Tree& T, position p)`
            * 取父`position Parent (Tree& T, position p)`
            * 插孩`int InsertChild (Tree& T, position p, TElemType x)`
            * 删孩`int DeleteChild (Tree& T, position p, int i)`
            * 删树`void DeleteSubTree (Tree& T, position t)`
            * 遍历`void Traversal (Tree& T, position p)`
    2. 二叉树
        1. 二叉树的概念
            * 特点
                * 每结点最多两个子女，分左右
                * 定义递归，子树必是二叉树
                * 5种形态
                    * 空二叉树
                    * 只有根结点
                    * 右子树为空
                    * 左子树为空
                    * 左右子树不为空
                * 树的术语适用于二叉树，但二叉树不是树
                    * 分左右
        2. 二叉树的性质
            * 第i层结点<=2^(i-1)
            * 深度为k的二叉树，k<=结点数<=2^k-1
            * 0度叶结点数=2度结点数+1
            * 满二叉树：除底层结点0度，其余结点2度
            * 完全二叉树：底层以上满，底层左起满
            * 丰满二叉树：底层以上满，底层无要求
            * n结点完全二叉树或丰满二叉树深度=ln(n+1)/ln2向上取整
            * 将n结点完全二叉树从按行从上至下，每行从左至右转换为一维数组，对结点i(1<=i<=n)
                * 若i=1，结点i为根；若i>1，父结点为结点i/2向下取整
                * 若2i<=n，则左子女为结点2i
                * 若2i+1<=n，则右子女为结点2i+1
                * 结点i所在层次为ln(i)/ln(2)向下取整+1
        3. 二叉树的主要操作
            * 创建`void InitBTree (BiTNode*& T)`
            * 删除`void ClearBTree (BiTNode*& T)`
            * 左孩`BiTNode* LeftChild (BiTNode* p)`
            * 右孩`BiTNode* RightChild (BiTNode* p)`
            * 取父`BiTNode* Parent (BiTNode* p>;
            * 取值`int GetData (BiTNode* p, TElemType& x)`
            * 建树`void CreateBinTree (BiTNode*& T)`
            * 印树`void PrintBinTree (BiTNode*& T)`
            * 树高`int Height (BiTNode*& T)`
            * 前序遍历`void PreOrder (BiTNode* T)`根>左>右
            * 中序遍历`void InOrder (BiTNode* T)`左>根>右
            * 后序遍历`void PostOrder (BiTNode* T)`左>右>根
            * 层序遍历`void LevelOrder (BiTNode* T)`顶>底
    3. 二叉树的存储表示
        1. 二叉树的顺序存储表示
        2. 二叉树的链表存储表示
            * 二叉链表`{data; lchild; rchild}`
            * 三叉链表`{data; lchild; rchild; parent}`
                * 可用二叉链表+路径栈替代，节省存储空间
    4. 二叉树的遍历
        1. 二叉树遍历的递归算法
            * VLR 前序遍历
            * LVR 中序遍历
            * LRV 后序遍历
            * VRL
            * RVL
            * RLV
        2. 递归遍历算法的应用举例
        3. 二叉树遍历的非递归算法
            * 欧拉巡回遍历
            * 利用栈实现前序、中序、后序遍历
            * 利用队列实现层序遍历
        4. 非递归遍历算法的应用举例
        5. 二叉树的计数
            * 利用前序序列和中序序列确定二叉树
                * 前序定根
                * 中序分左右
            * n结点二叉树的不同形状的棵树=C(2n,n)/(n+1)
    5. 线索二叉树
        1. 线索二叉树的概念
            * 空lchild存放前趋结点指针
            * 空rchild存放后继结点指针
        2. 线索二叉树的种类
            * 中序线索树
            * 前序线索树
            * 后序线索树
            * 层序线索树
        3. 中序线索二叉树的建立和遍历
        4. 前序与后序线索二叉树
    6. 树与森林
        1. 树的存储表示
            * 父指针表示法
            * 子女链表表示法
            * 广义表表示法
            * 子女-兄弟链表表示法
        2. 森林与二叉树的转换
            * 树可按照其子女-兄弟链表表示转换成唯一的一棵二叉树
            * 森林可先将每棵树转换为二叉树再依次在右子树连接，最终转换为一棵二叉树（唯一？树有先后？）
            * 二叉树可转换成唯一的树和森林
        3. 树与森林的深度优先遍历
            * 树的深度优先遍历
                * 先根次序遍历
                    * 若树=空则返回，访问树根，依次先根次序遍历子树
                    * 等于对应二叉树的前序遍历
                * 后根次序遍历
                    * 若树=空则返回，依次后根次序遍历子树，访问树根
                    * 等于对应二叉树的中序遍历
            * 森林的深度优先遍历
                * 先根次序遍历
                    * 若森林=空则返回，访问森林根（第一棵树根），先根遍历第一棵树的子树森林，先根遍历其他树组成的森林
                    * 等于对应二叉树的前序遍历
                * 中根次序遍历
                    * 若森林=空则返回，先根遍历第一棵树的子树森林，访问森林根（第一棵树根），先根遍历其他树组成的森林
                    * 等于对应二叉树的中序遍历
        4. 树与森林的广度优先遍历
            * 树的广度优先遍历与二叉树的层序遍历类似
            * 森林的广度优先遍历
        5. 树遍历算法的应用举例
6. 树与二叉树的应用
    1. 二叉查找树
        1. 二叉查找树的概念
            * 结点有关键码，且互不相同
            * 左子树（如果非空）关键码小于树根关键码
            * 右子树（如果非空）关键码大于树根关键码
            * 左右子树都是二叉查找树
        2. 二叉査找树的查找
        3. 二叉查找树的插入
        4. 二叉査找树的删除
            * 左子树为空，右子树顶替
            * 右子树为空，左子树顶替
            * 左右子树为空，右子树中序首结点顶替
        5. 二叉査找树的性能分析
    2. AVL树
        1. AVL树的概念
        2. 平衡化旋转
            * 从插入点向树根回溯检查左右子树高度差，若发现不平衡，沿回溯路径向下取两点
            * 若三点成直线采用单旋转进行平衡化
                * 左单旋转（根的右子树的右子树插入，因此称RR旋转）
                    * 树根替代右子树的左子树
                    * 右子树的左子树成为原树根的右子树
                * 右单旋转（根的左子树的左子树插入，因此称LL旋转）
                    * 树根替代左子树的右子树
                    * 左子树的右子树成为原树根的左子树
            * 若三点成折线采用双旋转进行平衡化
                * 先左后右双旋转（根的左子树的右子树插入，因此称LR旋转）
                    * 末端先左旋转
                    * 树根再右旋转
                * 先右后左双旋转（根的右子树的左子树插入，因此称RL旋转）
                    * 末端先右旋转
                    * 树根再左旋转
        3. AVL树的插入
            * 结点插右孩位置，父结点平衡因子加1
            * 结点插左孩位置，父结点平衡因此减1
            * 插入后父结点平衡因子为0
                * 已平衡，高度没有增加，无需平衡化，返回主程序
            * 插入后父结点平衡因子为1或-1
                * 没有失去平衡，高度增加，无需平衡化，需回溯父结点
            * 插入后父结点平衡因子为2或-2
                * 平衡被破坏，需要平衡化，无需回溯
        4. AVL树的删除
            * 若被删结点有两个子女，用被删结点的中序直接前趋（即被删结点左子树中键值最大结点）的数据复制至被删结点，再考虑删除该直接前趋结点（该结点最多只有一个子女，因此删除问题转化为下面的情况）
            * 若被删结点最多只有一个子女，则被删结点父结点指向被删结点的指针改为指向被删结点的子女或置NULL（无子女的情况），子树高度减1，并回溯平衡
                * 父结点平衡因子从0变成1或-1
                    * 无需平衡化，无需回溯
                * 父结点平衡因子从1或-1变成0
                    * 无需平衡化，需回溯（因高度减少）
                * 父结点平衡因子从1变成2或从-1变成-2
                    * 若长子树平衡因子为0，需单旋转平衡化，高度不变，无需回溯
                    * 若长子树平衡因子符号相同（1或-1），需单旋转平衡化，高度减1，需回溯
                    * 若长子树平衡因子符号相反，需双旋转平衡化，高度减1，需回溯
        5. AVL树的性能分析
    3. Huffman树
        1. 带权路径长度的概念
        2. Huffman树的概念
            * Huffman算法
                * 最小权重的两个元素组合为二叉树
                * 从集合中删除这两个元素
                * 将组合后的二叉树作为元素加入集合
                * 组合后的二叉树权重为两元素权重之和
                * 重复直至集合中只剩下一棵二叉树
        3. 最优判定树
            * 使用Huffman算法
            * 使用Hu-Tucker(T.C.Hu和A.C.Tucker)算法
                * 按照初始顺序排列各结点
                * 找出权重和最小的相邻结点组成二叉树
                * 组合后的二叉树替换原来两结点的位置
                * 组合后的二叉树权重为两结点权重之和
                * 重复直至只剩下一个二叉树
        4. Huffman编码
    4. 堆
        1. 小根堆和大根堆
            * 堆的概念
                * 任意根都比它的任一子结点（若存在）键码小，称为小根堆
                * 任意根都比它的任一子结点（若存在）键码大，称为大根堆
        2. 堆的建立
            * 将元素数组视为按照完全二叉树顺序排列{k0, k1, ..., k(n-1)}
            * 找出编号最大的分支结点，即最大元素（k(n-1)）的父结点（k(向下取整((n-1-1)/2))）
            * 对找到的分支结点使用向下调整处理
                * 与两子结点中较小（大根堆则选较大）者比较，若父大于（大根堆则小于）子，则调换位置
                * 若发生交换则递归处理交换后的子结点
            * 从大到小依次使用向下调整处理各分支结点
        3. 堆的插人
            * 将要插入的元素添加到数组末端
            * 找到该元素的父结点
            * 对该结点进行向上调整处理
                * 与父结点键码进行比较，若子小于（大根堆则大于）父，则调换位置
                * 若发生调换则递归处理交换后的父结点
        4. 堆的删除
            * 以最后结点替换要删除的元素
            * 对替换后的结点进行向下调整处理
    5. 并查集
        1. 并查集的定义及其实现
            * 支持3种操作
                * `Union (Root1, Root2)`把`Root2`并入`Root1`，要求`Root1`、`Root2`互不相交
                * `Find (x)`查找单元素`x`所在的集合
                * `InitUFSets (s)`初始化函数，将并查集中`s`个元素初始化为`s`个子集
        2. 并查集操作的分析和改进
            * 加权合并
                * 合并时令结点少的树成为结点多的树的子树
            * 用折叠规则压缩路径
                * `int CollapsingFind (UFSets& S, int i)`
                * 将`i`以及从`i`到根路径上的结点变成根的子女
    6. 八皇后问题与树的剪枝
        1. 八皇后问题的提出
        2. 八皇后问题的状态树
        3. 八皇后问题算法
7. 图
    1. 图的基本概念
        1. 与图有关的若干概念
            * 术语
                * 完全图：边=n(n-1)/2
                * 权重：边的数值
                * 网络：带权图
                * 邻接顶点
                    * 无向图：边两端互为邻接点
                    * 有向图：<u, v>u邻接到v，v邻接自u
                * 子图
                * 顶点的度：顶点关联的边数
                * 路径：顶点序列或边序列
                * 路径长度：
                    * 不带权图：边数
                    * 带权图：各边权重之和
                * 简单路径与回路
                    * 简单路径：路径顶点不重复
                    * 回路（环）：第一点与最后一点重合
                * 连通图与连通分量
                    * 连通：两点间有路径
                    * 连通图：任两点连通
                    * 连通分量：非连通图的极大连通子图
                * 生成树
        2. 图的基本操作
            * 创建`void CreateGraph (Graph& G, int n, int m)`
            * 打印`void PrintGraph (Graph& G)`
            * 初始化`void InitGraph (Graph& G)`
            * 查顶点`int GetVertexPos (Graph& G, VType x)`
            * 顶点数`int NumberOfVertices (Graph& G)`
            * 边数`int NumberOfEdges (Graph& G)`
            * 取值`VType GetValue (Graph& G, int i)`
            * 取权重`WType GetWeight (Graph& G, int v1, int v2)`
            * 首邻接点`int FirstNeighbor (Graph& G, int v)`
            * 相对次邻接点`int NextNeighbor (Graph& G, int v, int w)`
            * 插入点`void InsertVertex (Graph& G, VType vertex)`
            * 插入边`void InsertEdge (Graph& G, int v1, int v2, WType weight)`
            * 删点`void RemoveVertex (Graph& G, int v)`
            * 删边`void RemoveEdge (Graph& G, int v1, int v2)`
    2. 图的存储结构
        1. 图的邻接矩阵表示
        2. 图的邻接表表示
        3. 邻接矩阵表示与邻接表表示的比较
        4. 图的邻接多重表表示
    3. 图的遍历
        1. 深度优先搜索
        2. 广度优先搜索
        3. 连通分量
        4. 重连通图
        5. 有向图的强连通分量
    4. 最小生成树
        1. 最小生成树求解和贪婪法
        2. Kruskal算法
        3. Prim算法
    5. 最短路径
        1. 非负权重的单源最短路径
        2. 所有顶点之间的最短路径
        3. 无权重的最短路径
    6. 活动网络
        1. AOV网络与拓扑排序
        2. AOE网络与关键路径法
8. 查找
    査找的基本概念
    査找的概念
    査找算法的性能分析
    顺序査找法
    在顺序表上的顺序査找算法
    在线性链表上的顺序査找算法
    折半查找法
    折半査找法
    次优査找树：折半査找的改进方法
    斐波那契査找：折半査找的变形
    插值査找：折半査找的变形
    B树
    索引顺序表与分块査找
    2多级索引结构与讲叉査找树
    B树的概念
    B树上的査找
    B树上的插入
    B树上的删除
    B+树
    散列表及其査找
    散列的概念
    常见的散列函数
    解决冲突的开地址法
    解决冲突的链地址法
    散列法分析
第章内排序
排序的概念
排序的概念
排序算法的性能
数据表的结构定义
插人排序
直接插人排序
基于链表的直接插人排序
折半插入有g序
希尔排序
交换排序
起泡排序
快速排序
快速排序的改进算法
选择排序
简单选择排序
堆排序
锦标赛排序
归并排序
二路归并排序的设计思路
二路归并排序的递归算法
基于链表的归并排序算法
迭代的归并排序算法
S基数排序
S基数排序
MSD基数排序
LSD基数排序
内排序算法的分析和比较
排序方法的下界
分布计数排序
各种内排序方法的比较
习题
第章外排序
主存储器和外存储器
,磁带
磁盘存储器
XI
第章内排序
排序的概念
排序的概念
排序算法的性能
数据表的结构定义
插人排序
直接插人排序
基于链表的直接插人排序
折半插入有g序
希尔排序
交换排序
起泡排序
快速排序
快速排序的改进算法
选择排序
简单选择排序
堆排序
锦标赛排序
归并排序
二路归并排序的设计思路
二路归并排序的递归算法
基于链表的归并排序算法
迭代的归并排序算法
S基数排序
S基数排序
MSD基数排序
LSD基数排序
内排序算法的分析和比较
排序方法的下界
分布计数排序
各种内排序方法的比较
习题
第章外排序
主存储器和外存储器
,磁带
磁盘存储器
XI